Based on a patch by Frederik Tilmann, posted at http://forum.flightgear.org/viewtopic.php?f=31&t=21972#p202275

--- atlas-0.4_p20140519/src/NavData.hxx
+++ atlas-0.4_p20140519/src/NavData.hxx
@@ -219,6 +219,7 @@
     void _loadAirways640(const gzFile& arp);
     void _checkEnd(AwyLabel &end, bool isLow);
     void _loadAirports810(const gzFile& arp);
+    void _loadAirports1000(const gzFile& arp);
 
     Searcher *_searcher;
 
--- atlas-0.4_p20140519/src/NavData.cxx
+++ atlas-0.4_p20140519/src/NavData.cxx
@@ -1397,3 +1397,304 @@
 	_frustumCullers[AIRPORTS]->culler().addObject(ap);
     }
 }
+
+
+void NavData::_loadAirports1000(const gzFile& arp)
+{
+    char *line;
+    ARP *ap = NULL;
+
+    while (gzGetLine(arp, &line)) {
+	int lineCode, offset;
+
+	if (strcmp(line, "") == 0) {
+	    // Blank line.
+	    continue;
+	} 
+
+	if (strcmp(line, "99") == 0) {
+	    // Last line.
+	    break;
+	}
+
+	sscanf(line, "%d%n", &lineCode, &offset);
+	line += offset;
+	switch (lineCode) {
+	  case 1:
+	  case 16:
+	  case 17:
+	    {
+		// The presence of a 1/16/17 means that we're starting a
+		// new airport/seaport/heliport, and therefore ending an
+		// old one.  Deal with the old airport first.
+		if (ap != NULL) {
+		    // Calculate the airport's center in lat, lon.
+		    __airportLatLon(ap);
+		    // Add it to our airports vector.
+		    _airports.push_back(ap);
+		    // Add our airport text to the searcher object.
+		    _searcher->add(ap);
+		    // Add to our culler.
+		    _frustumCullers[AIRPORTS]->culler().addObject(ap);
+
+		    ap = NULL;
+		}
+
+		// EYE - add seaports and heliports!  (Note: the
+		// classification of seaports is iffy - Pearl Harbor
+		// is called an airport, even though it's in the
+		// ocean, and Courchevel is called a seaport, even
+		// though it's on top of a mountain).
+		if (lineCode != 1) {
+		    // We only handle airports (16 = seaport, 17 = heliport)
+		    break;
+		}
+
+		// Create a new airport record.
+		ap = new ARP;
+
+		float elevation;
+		int controlled;
+		char code[5];	// EYE - safe?
+
+		sscanf(line, "%f %d %*d %s %n", 
+		       &elevation, &controlled, code, &offset);
+		line += offset;
+
+		ap->elev = elevation * SG_FEET_TO_METER;
+		// FJT: according to 1000 spec this parameter is deprecated - still leave it in
+		ap->controlled = (controlled == 1);
+		ap->id = code;
+		ap->name = line;
+		// This will be set to true if we find a runway with
+		// any kind of runway lighting.
+		ap->lighting = false;
+		// If set to true, then beaconLat and beaconLon
+		// contain the location of the beacon.
+		ap->beacon = false;
+	    }
+
+	    break;
+	  case 100:
+	    // 100: runway (i.e. ignore water runway 101, helipad 102)
+	    {
+		if (ap == NULL) {
+		    // If we're not working on an airport (ie, if this is
+		    // a heliport), just continue.
+		    break;
+		}
+
+		double lat1, lon1,lat2,lon2,latdif,londif;
+		char rwyid1[4],rwyid2[4];	// EYE - safe?
+		float heading, length, width;
+		int centre_light,edge_light,reil_light,tdz_light;
+		// char *lighting;
+
+		//		sscanf(line, "%lf %lf %s %n", &lat, &lon, rwyid, &offset);
+		// skipped parameters: surface type, runway should surface type, smoothness, auto-generate distance signs
+		sscanf(line,"%f %*d %*d %*f %d %d %*d %n",&width,&centre_light,&edge_light,&offset);
+		line += offset;
+		if ( edge_light || centre_light) 
+		  ap->lighting=true;
+
+		// skipped values: displaced threshold, overrun, runway markings, approach lighting, runway touchdown lighting, runway end identifier light
+		sscanf(line,"%4s %lf %lf %*f %*f %*d %*d %d %d %n",rwyid1,&lat1,&lon1,&tdz_light,&reil_light,&offset);
+		line += offset;
+		if ( tdz_light || reil_light) 
+		  ap->lighting=true;
+		// skipped values: displaced threshold, overrun, runway markings, approach lighting, runway touchdown lighting, runway end identifier light
+		sscanf(line,"%4s %lf %lf %*f %*f %*d %*d %d %d %n",rwyid2,&lat2,&lon2,&tdz_light,&reil_light,&offset);
+		line += offset;
+		if ( tdz_light || reil_light) 
+		  ap->lighting=true;
+		// We ignore taxiways and helipads.
+		//		if (strcmp(rwyid, "xxx") == 0) {
+		//    break;
+		//}
+		//if (strncmp(rwyid, "H", 1) == 0) {
+		//    break;
+		//}
+
+		// Strip off trailing x's.
+		int firstX = strcspn(rwyid1, "x");
+		if (firstX > 0) {
+		    rwyid1[firstX] = '\0';
+		}
+		assert(strlen(rwyid1) <= 3);
+
+		// Runway!
+		RWY *rwy = new RWY;
+
+		//		sscanf(line, "%f %f %*f %*f %f %n", 
+		//      &heading, &length, &width, &offset);
+		// lighting = line + offset;
+
+		rwy->lat = (lat1+lat2)/2.0;
+		rwy->lon = (lon1+lon2)/2.0;
+		latdif=(lat2-lat1)*SGD_DEGREES_TO_RADIANS*SG_EQUATORIAL_RADIUS_M;
+		londif=(lon2-lon1)*SGD_DEGREES_TO_RADIANS*cos(SGD_DEGREES_TO_RADIANS*rwy->lat)*SG_EQUATORIAL_RADIUS_M;
+                rwy->hdg = float(atan2(londif,latdif)*SGD_RADIANS_TO_DEGREES);
+		//fprintf(stderr,"DEBUG: airport: %lf %lf %lf %lf latdif %lf, londif %lf head %f\n",lat1,lon1,lat2,lon2,latdif,londif,rwy->hdg);
+		rwy->length = sqrt(latdif*latdif+londif*londif);
+		// rwy->length = length * SG_FEET_TO_METER;
+		// 	rwy->width  = width * SG_FEET_TO_METER;
+		rwy->width  = width; 
+		rwy->id = rwyid1;
+		ap->rwys.push_back(rwy);
+
+		__runwayExtents(rwy, ap->elev);
+		ap->_bounds.extend(&(rwy->_bounds));
+
+		// According to the FAA's "VFR Aeronautical Chart
+		// Symbols", lighting codes on VFR maps refer to
+		// runway lights (not approach lights).
+		//
+		// In apt.dat, visual approach, runway, and approach
+		// lighting is given by a six-digit "number" (which we
+		// treat as a string).  We're concerned with digits 2
+		// and 5, which concern the runway itself.  If the
+		// value is '1', there is no runway lighting.
+		//
+		// Note that the apt.dat database does not tell us
+		// about lighting limitations, nor whether the
+		// lighting is pilot-controlled.
+		//		if ((lighting[1] != '1') || (lighting[4] != '1')) {
+		//		    ap->lighting = true;
+		//		}
+	    }
+
+	    break;
+	  case 18: 
+	    if (ap != NULL) {
+		// Beacon
+		double lat, lon;
+		int beaconType;
+
+		sscanf(line, "%lf %lf %d", &lat, &lon, &beaconType);
+		if (beaconType != 0) {
+		    ap->beacon = true;
+		    ap->beaconLat = lat;
+		    ap->beaconLon = lon;
+		}
+	    }
+	    break;
+	  case WEATHER:		// AWOS, ASOS, ATIS
+	  case UNICOM:		// Unicom/CTAF (US), radio (UK)
+	  case DEL:		// Clearance delivery
+	  case GND:		// Ground
+	  case TWR:		// Tower
+	  case APP:		// Approach
+	  case DEP:		// Departure
+	      {
+		  // ATC frequencies.
+		  //
+		  // Here's a sample, from LFPG (Paris Charles De
+		  // Gaulle), which is a rather extreme case:
+		  //
+		  // 50 12712 DE GAULLE ATIS
+		  // 53 11810 DE GAULLE TRAFFIC
+		  // 53 11955 DE GAULLE TRAFFIC
+		  // 53 12160 DE GAULLE GND
+		  // 53 12167 DE GAULLE TRAFFIC
+		  // 53 12177 DE GAULLE GND
+		  // 53 12177 DE GAULLE GND
+		  // 53 12180 DE GAULLE GND
+		  // 53 12192 DE GAULLE TRAFFIC
+		  // 53 12192 DE GAULLE TRAFFIC
+		  // 53 12197 DE GAULLE GND
+		  // 53 12197 DE GAULLE GND
+		  // 54 11865 DE GAULLE TWR
+		  // 54 11925 DE GAULLE TWR
+		  // 54 12090 DE GAULLE TWR
+		  // 54 12360 DE GAULLE TWR
+		  // 54 12532 DE GAULLE TWR
+		  //
+		  // [...]
+		  //
+		  // There are several important things to note:
+		  //
+		  // (1) There many be several entries for a given
+		  //     type.  For example, there is only one WEATHER
+		  //     entry (type code 50), but 10 GND entries
+		  //     (type code 53).
+		  //
+		  // (2) There may be several frequencies with the
+		  //     same name in a given type.  For example,
+		  //     there are 4 GND entries labelled "DE GAULLE
+		  //     TRAFFIC", and 6 labelled "DE GAULLE GND".
+		  //     They are not guaranteed to be grouped
+		  //     together.  
+		  //
+		  //     When rendering these, we only print the label
+		  //     once, and all frequencies with that label are
+		  //     printed after the label.  This makes for a
+		  //     less cluttered display:
+		  //
+		  //     DE GAULLE TRAFFIC 118.1 119.55 121.675 121.925
+		  //
+		  // (3) There may be duplicates.  For example, '53
+		  //     12192 DE GAULLE TRAFFIC' is given twice.  The
+		  //     duplicates should presumably be ignored.
+		  //
+		  // (4) Frequencies are given as integers, and should
+		  //     be divided by 100.0 to give the true
+		  //     frequency in MHz.  That is, 11810 is 118.1
+		  //     MHz.  In addition, they are missing a
+		  //     significant digit: 12192 really means 121.925
+		  //     MHz, not 121.92 MHz (communications
+		  //     frequencies have a 25 kHz spacing).  So, we
+		  //     need to correct frequencies with end in the
+		  //     digits '2' and '7'.
+		  //
+		  //     Internally, we also store the frequencies as
+		  //     integers, but multiplied by 1000.0, not
+		  //     100.0.  And we add a final '5' when
+		  //     necessary.  So, we store 12192 as 121925, and
+		  //     11810 as 118100.
+
+	          // EYE - what should I do about multiple frequencies
+	          // of one type?  A: Check San Jose (KSJC) - it has 2
+	          // CT frequencies, and just lists them.  However,
+	          // the VFR_Chart_Symbols.pdf file says that it lists
+	          // the "primary frequency."
+
+	          // Note: Unicom frequencies are written in bold
+	          // italics, others in bold.  CT seems to be written
+	          // slightly larger than the others.
+
+	          // Note: Some airports, like Reid-Hillview, have
+	          // CTAF and UNICOM.  CTAF is written with a circled
+	          // C in front, the frequency bold and slightly
+	          // enlarged (like CT), UNICOM in bold italics.
+
+		  if (ap != NULL) {
+		      int freq;
+
+		      sscanf(line, "%d %n", &freq, &offset);
+		      line += offset;
+
+		      FrequencyMap& f = ap->freqs[(ATCCodeType)lineCode];
+		      set<int>& freqs = f[line];
+		      if ((freq % 10 == 2) || (freq % 10 == 7)) {
+			  freqs.insert(freq * 10 + 5);
+		      } else {
+			  freqs.insert(freq * 10);
+		      }
+		  }
+	      }
+	    break;
+	}
+    }
+
+    if (ap != NULL) {
+	// Calculate the airport's center in lat, lon.
+	__airportLatLon(ap);
+	// Add it to our airports vector.
+	_airports.push_back(ap);
+	// Add our airport text to the searcher object.
+	_searcher->add(ap);
+	// Add to our culler.
+	_frustumCullers[AIRPORTS]->culler().addObject(ap);
+    }
+}
+
